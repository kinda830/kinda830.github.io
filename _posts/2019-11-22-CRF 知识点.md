# CRF çŸ¥è¯†ç‚¹

## 1. é—®é¢˜èƒŒæ™¯

â€‹	æœºå™¨å­¦ä¹ é¢†åŸŸå†…å¾ˆå¤šå¸¸è§é—®é¢˜éƒ½æ¶‰åŠåˆ°å¯¹å½¼æ­¤ç›¸äº’ç‹¬ç«‹çš„å­¤ç«‹æ•°æ®ç‚¹è¿›è¡Œåˆ†ç±»ã€‚æ¯”å¦‚ï¼šé¢„æµ‹ç»™å®šå›¾åƒä¸­æ˜¯å¦åŒ…å«æ±½è½¦æˆ–ç‹—ï¼Œæˆ–é¢„æµ‹å›¾åƒä¸­çš„æ‰‹å†™å­—ç¬¦æ˜¯ 0 åˆ° 9 ä¸­çš„å“ªä¸€ä¸ªã€‚

â€‹	äº‹å®è¯æ˜ï¼Œå¾ˆå¤šé—®é¢˜éƒ½ä¸åœ¨ä¸Šè¿°èŒƒå›´å†…ã€‚æ¯”å¦‚è¯´ï¼Œç»™å®šä¸€ä¸ªå¥å­ã€Œæˆ‘çˆ±åŒ—äº¬å¤©å®‰é—¨ã€ï¼Œç„¶åæ ‡æ³¨æ¯ä¸ªè¯çš„è¯æ€§ï¼ˆåè¯ã€ä»£è¯ã€åŠ¨è¯ã€å½¢å®¹è¯ç­‰ï¼‰ã€‚æ­£å¦‚è¿™ä¸ªç®€å•ä¾‹å­æ‰€è¡¨ç°å‡ºçš„é‚£æ ·ï¼šæˆ‘ä»¬ä¸èƒ½é€šè¿‡å•ç‹¬å¤„ç†æ¯ä¸ªè¯æ¥è§£å†³è¿™ä¸ªä»»åŠ¡â€”â€”ã€Œçˆ±ã€æ ¹æ®ä¸Šä¸‹æ–‡çš„æƒ…å†µæ—¢å¯ä»¥æ˜¯åè¯ï¼Œä¹Ÿå¯ä»¥æ˜¯åŠ¨è¯ã€‚è¿™ä¸ªä»»åŠ¡å¯¹å¾ˆå¤šå…³äºæ–‡æœ¬çš„æ›´ä¸ºå¤æ‚çš„ä»»åŠ¡éå¸¸é‡è¦ï¼Œæ¯”å¦‚ä»ä¸€ç§è¯­è¨€åˆ°å¦ä¸€ç§è¯­è¨€çš„ç¿»è¯‘ã€æ–‡æœ¬è½¬è¯­éŸ³ç­‰ã€‚

â€‹	å¦‚è¯æ€§æ ‡æ³¨ç­‰é—®é¢˜ä¹Ÿå¯ä»¥é‡‡ç”¨å¸¸è§çš„åˆ†ç±»ç®—æ³•æ¥è§£å†³ï¼šå¯ä»¥é‡‡ç”¨é€å¸§ softmaxç­‰æ–¹æ³•ã€‚æ¨¡å‹è§£å†³å¦‚ä¸‹å›¾ï¼š

![1527042482806](CRF/1527042482806.png)

æ¨¡å‹ç»“æ„è§£é‡Šï¼š

1. ç¼–ç å±‚ï¼šå¯ä»¥é‡‡ç”¨RNNæˆ–CNNç­‰ç»“æ„å¯¹æ–‡æœ¬åºåˆ—è¿›è¡Œç¼–ç ï¼›
2. è¾“å‡ºå±‚ï¼šåºåˆ—æ¯ä¸€å¸§éƒ½é€šè¿‡ä¸€ä¸ªsoftmaxè¿›è¡Œæ¿€æ´»åˆ†ç±»ã€‚

ä½†æ˜¯ï¼Œè¿™ä¸ªæ¨¡å‹æœ‰ä¸ªé—®é¢˜ï¼šæ¯å¸§éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œæ²¡æœ‰è€ƒè™‘å‰åè¾“å‡ºç»“æœä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚è€Œæ¦‚ç‡å›¾æ¨¡å‹åˆ™æ˜¯ç”¨æ¥è§£å†³è¿™ç±»é—®é¢˜ã€‚

## 1. æ¦‚ç‡å›¾æ¨¡å‹

â€‹	æ¦‚ç‡å›¾æ¨¡å‹æ˜¯ä¸€ç§ç”¨æ¥å­¦ä¹ è¿™äº›å¸¦æœ‰ä¾èµ–çš„æ¨¡å‹çš„å¼ºå¤§æ¡†æ¶ã€‚æ¦‚ç‡å›¾æ¨¡å‹ï¼ˆæˆ–ç®€ç§°å›¾æ¨¡å‹ï¼‰åœ¨å½¢å¼ä¸Šæ˜¯ç”±å›¾ç»“æ„ç»„æˆçš„ã€‚å›¾çš„æ¯ä¸ªèŠ‚ç‚¹ï¼ˆnodeï¼‰éƒ½å…³è”äº†ä¸€ä¸ªéšæœºå˜é‡ï¼Œè€Œå›¾çš„è¾¹ï¼ˆedgeï¼‰åˆ™è¢«ç”¨äºç¼–ç è¿™äº›éšæœºå˜é‡ä¹‹é—´çš„å…³ç³»ã€‚

â€‹	æ ¹æ®å›¾æ˜¯æœ‰å‘çš„è¿˜æ˜¯æ— å‘çš„ï¼Œæˆ‘ä»¬å¯ä»¥å°†å›¾çš„æ¨¡å¼åˆ†ä¸ºä¸¤å¤§ç±»ï¼š

1. è´å¶æ–¯ç½‘ç»œï¼ˆâ€ŠBayesian networkï¼‰ï¼šä½¿ç”¨æœ‰å‘æ— ç¯å›¾è¡¨ç¤ºå˜é‡é—´çš„ä¾èµ–å…³ç³»ï¼šéšé©¬å°”å¯å¤«æ¨¡å‹

   ![è´å¶æ–¯ç½‘ç»œ](CRF/è´å¶æ–¯ç½‘ç»œ.jpeg)

2. é©¬å°”å¯å¤«ç½‘ç»œï¼ˆMarkov networksï¼‰ï¼šä½¿ç”¨æ— å‘å›¾è¡¨ç¤ºå˜é‡é—´çš„ç›¸å…³å…³ç³»ï¼šé©¬å°”å¯å¤«éšæœºåœº

   ![é©¬å°”å¯å¤«ç½‘ç»œ](CRF/é©¬å°”å¯å¤«ç½‘ç»œ.png)

## 2. æ¡ä»¶éšæœºåœº

â€‹	æ¡ä»¶éšæœºåœºï¼ˆconditional Randon Fieldï¼ŒCRFï¼‰æ˜¯ä¸€ç§åˆ¤åˆ«å¼æ— å‘å›¾æ¨¡å‹ã€‚æ¡ä»¶éšæœºåœºè¯•å›¾å¯¹å¤šä¸ªå˜é‡åœ¨ç»™å®šè§‚æµ‹å€¼åçš„æ¡ä»¶æ¦‚ç‡è¿›è¡Œå»ºæ¨¡ã€‚ä¸¾ä¾‹å¦‚ä¸‹ï¼š

â€‹	ä»¤ $$ G = <V, E> $$ è¡¨ç¤ºç»“ç‚¹ä¸æ ‡è®°å˜é‡ $$ y $$ ä¸­å…ƒç´ ä¸€ä¸€å¯¹åº”çš„æ— å‘å›¾ï¼Œ $$ y_v$$ è¡¨ç¤ºä¸ç»“ç‚¹ $$ v $$ å¯¹åº”çš„æ ‡è®°å˜é‡ï¼Œ$$ n(v) $$ è¡¨ç¤ºç»“ç‚¹ $$ v $$ çš„é‚»æ¥ç»“ç‚¹ï¼Œè‹¥å›¾ $$ G $$ çš„æ¯ä¸ªå˜é‡ $$ y_v $$ éƒ½æ»¡è¶³é©¬å°”å¯å¤«æ€§ï¼Œå³ï¼š
$$
P(y_v|x,y_{V\{v\}}) = P(y_v | x, y_{n(v)})
$$
åˆ™ $$ (y, x) $$ æ„æˆä¸€ä¸ªæ¡ä»¶éšæœºåœºã€‚

â€‹	ç†è®ºä¸Šï¼Œå›¾ $$ G $$ Â Â å¯å…·æœ‰ä»»æ„ç»“æ„ï¼Œåªè¦èƒ½è¡¨ç¤ºæ ‡è®°å˜é‡ä¹‹é—´çš„æ¡ä»¶ç‹¬ç«‹æ€§å…³ç³»å³å¯ã€‚ä½†åœ¨ç°å®åº”ç”¨ä¸­ï¼Œæœ€å¸¸ç”¨çš„æ˜¯é“¾å¼ç»“æ„ï¼Œå³é“¾å¼æ¡ä»¶éšæœºåœºï¼Œåº”ç”¨åœºæ™¯æ˜¯è¯æ€§æ ‡æ³¨ï¼Œåˆ†è¯ç­‰åœºæ™¯ã€‚

> é©¬å°”å¯å¤«æ€§è´¨ï¼šæ˜¯[æ¦‚ç‡è®º](https://baike.baidu.com/item/æ¦‚ç‡è®º)ä¸­çš„ä¸€ä¸ªæ¦‚å¿µï¼Œå› ä¸ºä¿„å›½æ•°å­¦å®¶[å®‰å¾·é›·Â·é©¬å°”å¯å¤«](https://baike.baidu.com/item/å®‰å¾·é›·Â·é©¬å°”å¯å¤«)å¾—åã€‚å½“ä¸€ä¸ª[éšæœºè¿‡ç¨‹](https://baike.baidu.com/item/éšæœºè¿‡ç¨‹)åœ¨ç»™å®šç°åœ¨çŠ¶æ€åŠæ‰€æœ‰è¿‡å»çŠ¶æ€æƒ…å†µä¸‹ï¼Œå…¶æœªæ¥çŠ¶æ€çš„æ¡ä»¶[æ¦‚ç‡åˆ†å¸ƒ](https://baike.baidu.com/item/æ¦‚ç‡åˆ†å¸ƒ)ä»…ä¾èµ–äºå½“å‰çŠ¶æ€ï¼›æ¢å¥è¯è¯´ï¼Œåœ¨ç»™å®šç°åœ¨çŠ¶æ€æ—¶ï¼Œå®ƒä¸è¿‡å»çŠ¶æ€ï¼ˆå³è¯¥è¿‡ç¨‹çš„å†å²è·¯å¾„ï¼‰æ˜¯æ¡ä»¶ç‹¬ç«‹çš„ï¼Œé‚£ä¹ˆæ­¤[éšæœºè¿‡ç¨‹](https://baike.baidu.com/item/éšæœºè¿‡ç¨‹)å³å…·æœ‰**é©¬å°”å¯å¤«æ€§è´¨**ã€‚ -- æ¥æºç™¾åº¦ç™¾ç§‘ã€‚

## 3. é“¾å¼æ¡ä»¶éšæœºåœº

â€‹	é“¾å¼æ¡ä»¶éšæœºåœºçš„å›¾ç»“æ„å¦‚ä¸‹ï¼š

![é“¾å¼æ¡ä»¶éšæœºåœº](CRF/é“¾å¼æ¡ä»¶éšæœºåœº.png)

é“¾å¼æ¡ä»¶éšæœºåœºæ˜¯æ¡ä»¶éšæœºåœºçš„ç‰¹ä¾‹ã€‚

â€‹	è®¾ $$ ğ‘‹=(ğ‘‹_1,ğ‘‹_2,\cdots,ğ‘‹_ğ‘›) $$ ï¼Œ$$ ğ‘Œ=(ğ‘Œ_1,ğ‘Œ_2,\cdots,ğ‘Œ_ğ‘›) $$ å‡ä¸ºçº¿æ€§é“¾è¡¨ç¤ºçš„éšæœºå˜é‡åºåˆ—ï¼Œè‹¥åœ¨ç»™å®šéšæœºå˜é‡åºåˆ— $$ X $$çš„æ¡ä»¶ä¸‹ï¼Œéšæœºå˜é‡åºåˆ— $$ Y $$ çš„æ¡ä»¶æ¦‚ç‡åˆ†å¸ƒ $$ ğ‘ƒ(ğ‘Œ|ğ‘‹) $$ æ„æˆæ¡ä»¶éšæœºåœºï¼Œå³æ»¡è¶³é©¬å°”ç§‘å¤«æ€§ï¼š
$$
P(Y_i | X, Y_1,\cdots,Y_{i-1},Y_{i+1},\cdots,Y_n) = P(Y_i|X, Y_{i-1}, Y_{i+1}) \\
i = 1,2,\cdots,n(åœ¨ i=1å’Œnæ—¶ï¼Œåªè€ƒè™‘å•è¾¹).
$$
åˆ™ç§° $$ P(y|x) $$ ä¸ºé“¾å¼æ¡ä»¶éšæœºåœºã€‚

â€‹	å¦‚ä¸‹æ˜¯åˆ©ç”¨é“¾å¼æ¡ä»¶éšæœºåœºæ¥è§£å†³è‡ªç„¶è¯­è¨€å¤„ç†ä¸­è¯æ€§æ ‡æ³¨çš„æ¨¡å‹ç»“æ„ï¼š

![1527042479585](CRF/1527042479585.png)

æ¨¡å‹ç»“æ„è§£é‡Šï¼š

1. ç¼–ç å±‚ï¼šå¯ä»¥ä½¿ç”¨RNNæˆ–è€…CNNç­‰ç»“æ„è¿›è¡Œæ–‡æœ¬åºåˆ—ç¼–ç ï¼›
2. è¾“å‡ºå±‚ï¼šè¾“å‡ºå±‚æ˜¯ä¸€ä¸ªCRFå±‚ã€‚

å¦‚ä¸‹æ˜¯ä¸€ä¸ªç”¨keraå®ç°çš„ä¸€ä¸ªCRFå±‚ï¼š

```python
from keras.layers import Layer
import keras.backend as K

class CRF(Layer):
    """
    	çº¯Keraså®ç°CRFå±‚
    	CRFå±‚æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå¸¦è®­ç»ƒå‚æ•°çš„lossè®¡ç®—å±‚ï¼Œå› æ­¤CRFå±‚åªç”¨æ¥è®­ç»ƒæ¨¡å‹ï¼Œ
    	è€Œé¢„æµ‹åˆ™éœ€è¦å¦å¤–å»ºç«‹æ¨¡å‹ã€‚
    """
    def __init__(self, ignore_last_label=False, **kwargs):
        """
        	ignore_last_labelï¼šå®šä¹‰è¦ä¸è¦å¿½ç•¥æœ€åä¸€ä¸ªæ ‡ç­¾ï¼Œèµ·åˆ°maskçš„æ•ˆæœ
        """
        self.ignore_last_label = 1 if ignore_last_label else 0
        super(CRF, self).__init__(**kwargs)
    def build(self, input_shape):
        self.num_labels = input_shape[-1] - self.ignore_last_label
        self.trans = self.add_weight(name='crf_trans',
                                     shape=(self.num_labels, self.num_labels),
                                     initializer='glorot_uniform',
                                     trainable=True)
    def log_norm_step(self, inputs, states):
        """
        	é€’å½’è®¡ç®—å½’ä¸€åŒ–å› å­
        	è¦ç‚¹ï¼š1ã€é€’å½’è®¡ç®—ï¼›2ã€ç”¨logsumexpé¿å…æº¢å‡ºã€‚
        	æŠ€å·§ï¼šé€šè¿‡expand_dimsæ¥å¯¹é½å¼ é‡ã€‚
        """
        states = K.expand_dims(states[0], 2) # (batch_size, output_dim, 1)
        trans = K.expand_dims(self.trans, 0) # (1, output_dim, output_dim)
        output = K.logsumexp(states+trans, 1) # (batch_size, output_dim)
        return output+inputs, [output+inputs]
    def path_score(self, inputs, labels):
        """
        	è®¡ç®—ç›®æ ‡è·¯å¾„çš„ç›¸å¯¹æ¦‚ç‡ï¼ˆè¿˜æ²¡æœ‰å½’ä¸€åŒ–ï¼‰
        	è¦ç‚¹ï¼šé€æ ‡ç­¾å¾—åˆ†ï¼ŒåŠ ä¸Šè½¬ç§»æ¦‚ç‡å¾—åˆ†ã€‚
        	æŠ€å·§ï¼šç”¨â€œé¢„æµ‹â€ç‚¹ä¹˜â€œç›®æ ‡â€çš„æ–¹æ³•æŠ½å–å‡ºç›®æ ‡è·¯å¾„çš„å¾—åˆ†ã€‚
        """
        point_score = K.sum(K.sum(inputs*labels, 2), 1, keepdims=True) # é€æ ‡ç­¾å¾—åˆ†
        labels1 = K.expand_dims(labels[:, :-1], 3)
        labels2 = K.expand_dims(labels[:, 1:], 2)
        labels = labels1 * labels2 # ä¸¤ä¸ªé”™ä½labelsï¼Œè´Ÿè´£ä»è½¬ç§»çŸ©é˜µä¸­æŠ½å–ç›®æ ‡è½¬ç§»å¾—åˆ†
        trans = K.expand_dims(K.expand_dims(self.trans, 0), 0)
        trans_score = K.sum(K.sum(trans*labels, [2,3]), 1, keepdims=True)
        return point_score+trans_score # ä¸¤éƒ¨åˆ†å¾—åˆ†ä¹‹å’Œ
    def call(self, inputs): # CRFæœ¬èº«ä¸æ”¹å˜è¾“å‡ºï¼Œå®ƒåªæ˜¯ä¸€ä¸ªloss
        return inputs
    def loss(self, y_true, y_pred): # ç›®æ ‡y_predéœ€è¦æ˜¯one hotå½¢å¼
        mask = 1-y_true[:,1:,-1] if self.ignore_last_label else None
        y_true,y_pred = y_true[:,:,:self.num_labels],y_pred[:,:,:self.num_labels]
        init_states = [y_pred[:,0]] # åˆå§‹çŠ¶æ€
        log_norm,_,_ = K.rnn(self.log_norm_step, y_pred[:,1:], init_states, mask=mask) # è®¡ç®—Zå‘é‡ï¼ˆå¯¹æ•°ï¼‰
        log_norm = K.logsumexp(log_norm, 1, keepdims=True) # è®¡ç®—Zï¼ˆå¯¹æ•°ï¼‰
        path_score = self.path_score(y_pred, y_true) # è®¡ç®—åˆ†å­ï¼ˆå¯¹æ•°ï¼‰
        return log_norm - path_score # å³log(åˆ†å­/åˆ†æ¯)
    def accuracy(self, y_true, y_pred): # è®­ç»ƒè¿‡ç¨‹ä¸­æ˜¾ç¤ºé€å¸§å‡†ç¡®ç‡çš„å‡½æ•°ï¼Œæ’é™¤äº†maskçš„å½±å“
        mask = 1-y_true[:,:,-1] if self.ignore_last_label else None
        y_true,y_pred = y_true[:,:,:self.num_labels],y_pred[:,:,:self.num_labels]
        isequal = K.equal(K.argmax(y_true, 2), K.argmax(y_pred, 2))
        isequal = K.cast(isequal, 'float32')
        if mask == None:
            return K.mean(isequal)
        else:
            return K.sum(isequal*mask) / K.sum(mask)
```

